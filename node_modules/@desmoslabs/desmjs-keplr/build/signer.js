"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeplrSigner = exports.DesmosTestnet = exports.DesmosMainnet = void 0;
const utils_1 = require("@cosmjs/utils");
const desmjs_1 = require("@desmoslabs/desmjs");
exports.DesmosMainnet = {
    chainId: "desmos-mainnet",
    chainName: "Desmos",
    rpc: "https://rpc.mainnet.desmos.network",
    rest: "https://api.mainnet.desmos.network",
    bip44: {
        coinType: 852,
    },
    bech32Config: {
        bech32PrefixAccAddr: "desmos",
        bech32PrefixAccPub: "desmospub",
        bech32PrefixValAddr: "desmosvaloper",
        bech32PrefixValPub: "desmosvaloperpub",
        bech32PrefixConsAddr: "desmosvalcons",
        bech32PrefixConsPub: "desmosvalconspub",
    },
    currencies: [
        {
            coinDenom: "DSM",
            coinMinimalDenom: "udsm",
            coinDecimals: 6,
            coinGeckoId: "desmos",
        },
    ],
    feeCurrencies: [
        {
            coinDenom: "udsm",
            coinMinimalDenom: "udsm",
            coinDecimals: 6,
            coinGeckoId: "desmos",
        },
    ],
    stakeCurrency: {
        coinDenom: "DSM",
        coinMinimalDenom: "udsm",
        coinDecimals: 6,
        coinGeckoId: "desmos",
    },
    gasPriceStep: {
        low: 0.01,
        average: 0.03,
        high: 0.05,
    },
    features: ["stargate", "ibc-transfer", "no-legacy-stdTx", "ibc-go"],
};
exports.DesmosTestnet = {
    chainId: "morpheus-apollo-2",
    chainName: "Desmos Testnet",
    rpc: "https://rpc.morpheus.desmos.network",
    rest: "https://lcd.morpheus.desmos.network",
    bip44: {
        coinType: 852,
    },
    bech32Config: {
        bech32PrefixAccAddr: "desmos",
        bech32PrefixAccPub: "desmospub",
        bech32PrefixValAddr: "desmosvaloper",
        bech32PrefixValPub: "desmosvaloperpub",
        bech32PrefixConsAddr: "desmosvalcons",
        bech32PrefixConsPub: "desmosvalconspub",
    },
    currencies: [
        {
            coinDenom: "DARIC",
            coinMinimalDenom: "udaric",
            coinDecimals: 6,
        },
    ],
    feeCurrencies: [
        {
            coinDenom: "udaric",
            coinMinimalDenom: "udaric",
            coinDecimals: 6,
        },
    ],
    stakeCurrency: {
        coinDenom: "DARIC",
        coinMinimalDenom: "udaric",
        coinDecimals: 6,
    },
    gasPriceStep: {
        low: 0.01,
        average: 0.03,
        high: 0.05,
    },
    features: ["stargate", "ibc-transfer", "no-legacy-stdTx", "ibc-go"],
};
/**
 * Signer that use Keplr to sign a transaction.
 */
class KeplrSigner extends desmjs_1.Signer {
    constructor(keplrClient, options) {
        super(desmjs_1.SignerStatus.NotConnected);
        this.chainInfo = exports.DesmosMainnet;
        this.signingMode = desmjs_1.SigningMode.DIRECT;
        this.signingMode = options.signingMode;
        this.chainInfo = options.chainInfo;
        this.client = keplrClient;
    }
    /**
     * Subscribes to all the Keplr events.
     * @private
     */
    subscribeToEvents() {
        // Subscribe to the Keplr Storage event
        window.addEventListener("keplr_keystorechange", async () => {
            // disconnect from the current wallet
            await this.disconnect();
            // connect to the new wallet
            await this.connect();
        });
    }
    /**
     * Implements Signer.
     */
    async connect() {
        if (this.status !== desmjs_1.SignerStatus.NotConnected && this.accountData) {
            return;
        }
        this.updateStatus(desmjs_1.SignerStatus.Connecting);
        // prompt the Keplr Desmos network configuration
        await KeplrSigner.setupChainNetwork(this.chainInfo);
        const account = await this.client.getKey(this.chainInfo.chainId);
        this.accountData = {
            address: account.bech32Address,
            algo: account.algo,
            pubkey: account.pubKey,
        };
        this.subscribeToEvents();
        // Connect Keplr client to the current chainId
        await this.client.enable(this.chainInfo.chainId);
        this.updateStatus(desmjs_1.SignerStatus.Connected);
    }
    /**
     * Implements Signer.
     */
    disconnect() {
        if (this.status !== desmjs_1.SignerStatus.Connected) {
            return Promise.resolve();
        }
        this.updateStatus(desmjs_1.SignerStatus.Disconnecting);
        this.accountData = undefined;
        this.updateStatus(desmjs_1.SignerStatus.NotConnected);
        return Promise.resolve();
    }
    /**
     * Implements Signer.
     */
    async getCurrentAccount() {
        return this.accountData;
    }
    /**
     * Implements Signer.
     *
     */
    async getAccounts() {
        this.assertConnected();
        const result = await this.client.getKey(this.chainInfo.chainId);
        return [
            {
                address: result.bech32Address,
                algo: result.algo,
                pubkey: result.pubKey,
            },
        ];
    }
    /**
     * Implements OfflineDirectSigner.
     */
    async signDirect(signerAddress, signDoc) {
        this.assertConnected();
        (0, utils_1.assert)(this.accountData);
        const signResponse = await this.client.signDirect(this.chainInfo.chainId, signerAddress, signDoc);
        return signResponse;
    }
    /**
     * Implements OfflineDirectSigner.
     */
    async signAmino(signerAddress, signDoc) {
        this.assertConnected();
        (0, utils_1.assert)(this.accountData);
        const signResponse = await this.client.signAmino(this.chainInfo.chainId, signerAddress, signDoc);
        return signResponse;
    }
    static async setupChainNetwork(chainInfo) {
        (0, utils_1.assert)(window.keplr);
        await window.keplr.experimentalSuggestChain(chainInfo);
    }
}
exports.KeplrSigner = KeplrSigner;
//# sourceMappingURL=signer.js.map